<h2>Algorithms - Coursera Notes</h2>
<p>Algorithms: method for solving a problem.
Data structure: method to store information.</p>
<h2>Week 1: Quick Union</h2>
<p>Steps to develop a usable algorithm:</p>
<ol>
<li>Model the problem</li>
<li>Find an algorithm to solve it</li>
<li>Fast enought / fits in memory?</li>
<li>If not, figure out why</li>
<li>Find a way to address the problem</li>
<li>Iterate until satisfied</li>
</ol>
<h3>Dynamic Connectivity</h3>
<p>Is there a path between two objects? Used in many applications. The union-find is a problem of maintaining a collection of disjoint sets and performing two operations.</p>
<p>We need to implement: find query and union command.</p>
<p>Find query: check if two objects are in the same component.
Union: replace components with their union.</p>
<p>We need to check our API design before implementing it.</p>
<p><strong>Quick Find (eager approach)</strong>:</p>
<ul>
<li>Data structure: integer array id[] of size N</li>
<li>Interpretation: two objects are connected if they have the same ID.</li>
</ul>
<p>Cost model: numer of array accesses.</p>
<p>Find: check if p and q have the same id.</p>
<p>Union: to merge components containing p and q, change all entries whose id equals id[p] to id[q].</p>
<p><strong>Quick Union (lazy approach):</strong></p>
<ul>
<li>Data structure: integer array id[] of size N</li>
<li>Interpretation: id[i] is parent of i</li>
<li>Root of i is id[id[id[...id[i]...]]]</li>
</ul>
<p>Find: check if p and q have the same root.</p>
<p>Union: to merge components containing p and q, set the id of p's root to the id of q's root.</p>
<p>Quick-find: union too expensive. Trees are flat.</p>
<p>Quick-union: trees can get tall. Find too expensive (could be N array accesses).</p>
<h3>Improvements</h3>
<p>Weighted quick-union</p>
<ul>
<li>Modify quick-union to avoid tall trees</li>
<li>Keep track of size of each tree (number of objects)</li>
<li>Balance by linking root of smaller tree to root of larger tree</li>
</ul>
<p>In sumamry, we try to avoid tall trees as we iterate through the array.</p>
<p><img src="image-1.png" alt="weighted tree comparison" /></p>
<pre><code class="language-python">
class QuickUnion:
    def __init__(self, n):
        self.id = [i for i in range(n)]
        self.sz = [1 for i in range(n)]

    def root(self, i):
        while i != self.id[i]:
            i = self.id[i]
        return i

    def connected(self, p, q):
        return self.root(p) == self.root(q)

    def union(self, p, q):
        i = self.root(p)
        j = self.root(q)
        self.id[i] = j

    def weighted_union(self, p, q):
        i = self.root(p)
        j = self.root(q)
        if i == j:
            return
        if self.sz[i] &lt; self.sz[j]:
            self.id[i] = j
            self.sz[j] += self.sz[i]
        else:
            self.id[j] = i
            self.sz[i] += self.sz[j]
</code></pre>
<p><strong>Running time:</strong></p>
<ul>
<li>Find: takes time proportional to depth of p and q</li>
<li>Union: takes constant time, given roots</li>
</ul>
<p>Depth of any node x is at most lg N.</p>
<h3>Union-Find Applications</h3>
<ul>
<li>Games</li>
<li>Dynamic connectivity</li>
<li>Percolation</li>
</ul>
<p><strong>Percolation</strong></p>
<p>N by N grid sites. A system percolates iff top and botom are connected by open sites.</p>
<p>Can be thought of as water flowing through surfaces. Or in Social networks if we want to know whether people are connected.</p>
<p><strong>The subtext of the problem is:</strong></p>
<ul>
<li>We model the problem</li>
<li>Then we find an algorithm</li>
<li>We check whether it's fast or not</li>
<li>We address the problem</li>
<li>And iterate...</li>
</ul>
<h2>Week 2: Analysis of Algorithms</h2>
<p>The key is running time; we used to have a cranking machine; how many cranks we need to do to compute.</p>
<p>Why analyze algorithms?</p>
<ul>
<li>Predict performance</li>
<li>Compare algorithms</li>
<li>Provide guarantees</li>
<li>Understand theoretical basis</li>
</ul>
<p>One of the most important ones is the FFT algorithm; takes only $N log N$ steps. Another one is the N-body simulation.</p>
<p>We use the scientific method to analyze algorithms: Observe, hypothesize, predict, verify, and validate.</p>
<p>Experiments must be <strong>reproducible</strong> and <strong>falsifiable</strong>.</p>
<p><strong>3-Sum Example</strong></p>
<p>How many distinct integers add up to zero.</p>
<p>Brute force: do a triple for loop. (it will take n^3)</p>
<p><strong>Mathematical models of runtime</strong></p>
<p>Donald Knuth first proposed the total run-time when programs were running for too long.</p>
<p>E.g., how many instructions as a function of input size N?</p>
<p>Turing said we should just count the most expensive operations instead of each addition.</p>
<p>By focusing on one operation you can simplify the frequency counts.</p>
<p><strong>Order of growth classifications</strong></p>
<p>Small set of functions: log N, N, NlogN, N^2, N^3, 2^N</p>
<p><img src="image-3.png" alt="Alt text" /></p>
<p>Based on binary search we can find a better algorithm for 3-Sum. We can use N^2 log N instead of N^3.</p>
<p>Instructions:</p>
<ul>
<li>Sort the N integers
<ul>
<li>Insertion sort: N^2</li>
</ul>
</li>
<li>For each pair of integers a and b, binary search for -(a+b)
<ul>
<li>Binary search: log N</li>
</ul>
</li>
<li>Only count if a[i] &lt; a[j]] &lt; a[k]</li>
</ul>
<h3>Types of analysis</h3>
<p>We have best case, worst case, and average case. Lower bound on cost, upper bound on cost, and expected cost.</p>
<p>We can have different approaches:</p>
<ol>
<li>Design for worst case</li>
<li>Randomize the input</li>
</ol>
<p>The main approach is to reduce variability by focusing on the worst case scenario. We want to find an optimal algorithm.</p>
<p>We have many notations</p>
<ul>
<li>Big Theta ($Big \theta$): asymptotic order of growth</li>
<li>Big Oh: to develop upper bounds</li>
<li>Big Omega: to develop lower bounds</li>
</ul>
<p>Example:</p>
<ul>
<li>3 Sum
<ul>
<li>Improved algorithm gives us O($N^2logN$)</li>
<li>Lower bound (proof that no algorithm can do better): $\omega(N)$</li>
</ul>
</li>
</ul>
<p>The approach:</p>
<ul>
<li>Develop algorithm</li>
<li>Prove a lower bound</li>
</ul>
<p>We can also have tilde notation. It's used to provide an approximate model. </p>
<h3>Memory</h3>
<p>Typical memory usage for primitive types:</p>
<ul>
<li>Boolean (1); Char (2); Double (8); Int (8)</li>
<li>Int[][] ~4MN; int[] ~4N+24; </li>
</ul>
<p>Typical memory usage for objects in Java:</p>
<ul>
<li>Object overhead 16 bytes</li>
<li>Ref 8 bytes</li>
<li>Padding multiple of 8 bytes</li>
</ul>
<h2>Week 2</h2>
<h3>Stacks and queues</h3>
<ul>
<li>They're fundamental data types</li>
<li>Stack has push and pop (LIFO)</li>
<li>Queue has enqueue and dequeue (FIFO)</li>
</ul>
<h3>Stacks</h3>
<ul>
<li>push(); pop(); isEmpty()</li>
<li>We build the stack with a LinkedList
<ul>
<li>push - insert node to the beginning</li>
<li>pop - remove node from the beginning</li>
</ul>
</li>
</ul>
<pre><code class="language-java">pop()
String item = first.item;
first = first.next;

push()
Node oldfirst = first;
first = new Node();
first.item = &quot;not&quot;;
first.next= oldfirst
</code></pre>
<ul>
<li>Every op takes constant time in the worst case.</li>
<li>A tack with N items uses ~40N bytes.</li>
<li>Every object in Java has 16 bytes of overhead.</li>
</ul>
<p><strong>Alternative Implementation</strong></p>
<ul>
<li>Use array s[] to store N items on stack</li>
<li>push(): add new item at S[N]</li>
<li>pop(): remove item from S[N-1]</li>
<li>Cons: need to define the capacity ahead of time</li>
</ul>
<p>We have to worry about loitering in Java. To avoid that we need to set the removed item to Null so it can be reclaimed by the garbage collector.</p>
<p><strong>Resizing arrays implementations</strong></p>
<p>Q: How can we grow the array?
A: If the array is full, create a new array of twice the size and copy the items. ~3N.</p>
<p>Q: How to shrink array?
A: Wait until the array is one-quarter full. Invariant; if the array is always between 25% and 100%</p>
<p>The worst case for push and pop will be N. </p>
<p><strong>Memory:</strong> It uses between 8N and 32N. </p>
<h3>Tradeoffs</h3>
<ul>
<li>Linked list: 
<ul>
<li>Every op takes constant time in worst case</li>
<li>We need to use extra time and space to deal with the links</li>
</ul>
</li>
<li>Stack
<ul>
<li>Every op takes constant amortized time</li>
<li>Less wasted space</li>
</ul>
</li>
</ul>
<h3>Queues</h3>
<p><strong>LinkedList</strong></p>
<pre><code>enqueue()

String item = first.item;
first = first.next;
return item;

dequeue()

Node oldlast = last;
Node last = new Node();
last.item =&quot;not&quot;;
last.next = null;

oldlast.next = last;
</code></pre>
