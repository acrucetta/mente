<h1>Notes on Operating Systems in 3 Easy Pieces</h1>
<h3>Anki Questions</h3>
<h4>System Calls</h4>
<p><strong>What does wait() do?</strong> The parent process calls wait()
to delay its execution until the child finishes executing. When the
child is done, wait() returns to the parent.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span>     <span class="dt">int</span> rc <span class="op">=</span> fork<span class="op">();</span> <span class="co">// Fork a new process</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>rc <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fork failed; exit</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;fork failed</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>rc <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Child process</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;hello, I am child (pid:</span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>getpid<span class="op">());</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Parent process</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> wc <span class="op">=</span> wait<span class="op">(</span>NULL<span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;hello, I am parent of </span><span class="sc">%d</span><span class="st"> (wc:</span><span class="sc">%d</span><span class="st">) (pid:</span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> rc<span class="op">,</span> wc<span class="op">,</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>getpid<span class="op">());</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>What does fork() do?</strong> The fork() system call is used
to create a new process</p>
<p><strong>What does exec() do?</strong> This system call is useful when
you want to run a program that is different from the calling program.
For example, calling fork() in p2.c is only useful if you want to keep
running copies of the same program</p>
<pre><code>
17 char *myargs[3];
18 myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)
19 myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count
20 myargs[2] = NULL; // marks end of array
21 execvp(myargs[0], myargs); // runs word count</code></pre>
<p>How does pipe() work? What are the main components? Why do we need
different modes of execution for a CPU? What is a trap, what is a trap
table? How can the OS effectively switch between processes? What do we
do when an OS process goes rogue? How does the CPU prevent it?</p>
<p><strong>What is a context switch?</strong></p>
<p>A context switch is conceptually simple: all the OS has to do is
<strong>save a few register values for the currently-executing
process</strong> (onto its kernel stack, for example) and
<strong>restore a few for the soon-to-be-executing process</strong>
(from its kernel stack).</p>
<p>By doing so, the OS thus <strong>ensures that when the
return-from-trap instruction is finally executed, instead of returning
to the process that was running, the system resumes execution of another
process.</strong></p>
<p><strong>How does the OS "baby proof" the CPU? What are the
equivalents?</strong></p>
<p>By during boot time setting up the trap handlers and starting an
interrupt timer, and then by only running processes in a restricted
mode. By doing so, the OS can feel quite assured that processes can run
efficiently, only requiring OS intervention to perform privileged
operations or when they have monopolized the CPU for too long and thus
need to be switched out.</p>
<p><strong>What is a timer interrupt? Why do we need it?</strong></p>
<p>The addition of a timer interrupt gives the OS the ability to run
again on a CPU even if processes act in a non-cooperative fashion. Thus,
this hardware feature is essential in helping the OS maintain control of
the machine.</p>
<h3>Scheduling</h3>
<p>What are the key assumptions made in the simple scheduling
examples?</p>
<ol type="1">
<li>Each job runs for the same amount of time.</li>
<li>All jobs arrive at the same time.</li>
<li>Once started, each job runs to completion.</li>
<li>All jobs only use the CPU (no I/O).</li>
<li>The run-time of each job is known.</li>
</ol>
<p>What are the key metrics for evaluating scheduling algorithms?</p>
<ul>
<li>Response time: time of first run - time of arrival</li>
<li>Turnaround time: time of completion - time of arrival</li>
</ul>
<p>What are the main types of simple scheduling policies mentioned and
what do they optimize for?</p>
<ul>
<li>First-in First-out (FIFO)</li>
<li>Shortest Job First (SJF): Optimizes turnaround time</li>
<li>Shortest Time-to-Completion First (STCF): Optimizes turnaround
time</li>
<li>Round Robin (RR): Optimizes response time</li>
</ul>
<p>What is the Multi-Level Feedback Queue (MLFQ) and what does it
optimize for?</p>
<p>MLFQ is a scheduling algorithm that varies job priority based on
observed behavior. It optimizes for turnaround time by running shorter
jobs first, while also trying to provide good responsiveness for
interactive users. It learns about processes as they run and uses their
history to predict future behavior.</p>
<p>What are the first two rules of the MLFQ?</p>
<ul>
<li>Rule 1: If Priority(A) &gt; Priority(B), A runs (B doesn’t).</li>
<li>Rule 2: If Priority(A) = Priority(B), A &amp; B run in RR.</li>
</ul>
<p>How does MLFQ handle newly arriving jobs and jobs that use their
entire time slice?</p>
<ul>
<li>Rule 3: When a job enters the system, it is placed at the highest
priority (the topmost queue).</li>
<li>Rule 4a: If a job uses up an entire time slice while running, its
priority is reduced (i.e., it moves down one queue).</li>
</ul>
<h2>Lectures</h2>
<h3>Lecture 1</h3>
<p>CPUs give us the illusion of running a program.</p>
<p>CPUs give us the abstraction of a process. A running program.</p>
<p>Processes have a private memory and "address space"; they also have
registers, and a stack pointer.</p>
<p>The computer can run programs in Kernel Mode (OS) and User Mod (user
program). Limited number of things.</p>
<p>Special services to operate on the OS can be called system calls.</p>
<p>Boot Time:</p>
<ul>
<li>OS starts in Kernel mode; it tells the hardware where to jump to
when the user specifies a trap #</li>
<li>We set up trap handlers in the OS; tell H/W where the trap handlers
are in OS memory</li>
</ul>
<p>Key Questions</p>
<ul>
<li>What if OS wants to run a operation that's higher</li>
<li>What if the OS wants to stop A, then run B</li>
</ul>
<h3>Lecture 2</h3>
<p>A CPU is basically a while loop that fetches the program counter.
Figures out which instruction it is. And executes it.</p>
<pre><code>while (1) {
  fetch(pc)
  decode
  increment pc
  (before executing)
    check permission (kernel or os)
    if not ok raise exception
      OS can get involved
  execute (can change pg)
    process interrupts
}</code></pre>
<p>Before it executes; it checks permission. Is this instrunction OK to
execute.</p>
<ul>
<li>It basically checks permissions; if the instruction is OK to execute
do it. If not raise exception.</li>
</ul>
<p>A timer interrupt runs every once in a while. It makes the CPU decide
if it wants to run the current program or switch.</p>
<p>CPU virtualization mechanisms.</p>
<p>At boot time: OS runs first at priviledged mode (kernel mode).</p>
<ul>
<li>Install handlers (tell hardware what to run)</li>
<li>Tell H/W what code to run on exception/interrupt traps</li>
<li>Initialize timer interrupt</li>
<li>Ready ro run user programs</li>
</ul>
<p>Timeline:</p>
<ul>
<li>A trap instruction:
<ul>
<li>Transitions us from user mode to kernel mode</li>
<li>Jumps into OS: target trap handlers</li>
<li>Save register state (to execute later)</li>
<li>Return from trap (opposite of above)</li>
</ul></li>
</ul>
<p>The OS must track different user processes. It uses a <strong>process
list</strong></p>
<ul>
<li>Per-process info:
<ul>
<li>state: ready, running</li>
</ul></li>
</ul>
<h2>A big problem: some operations are slow; the OS needs to do what to
do.</h2>
<h2>Book Notes</h2>
<h3>Scheduling: Introduction</h3>
<p><strong>Key assumptions:</strong></p>
<ol type="1">
<li>Each job runs for the same amount of time.</li>
<li>All jobs arrive at the same time.</li>
<li>Once started, each job runs to completion.</li>
<li>All jobs only use the CPU (i.e., they perform no I/O) 5. The
run-time of each job is known.</li>
</ol>
<p>Types of scheduling:</p>
<ul>
<li><strong>First-in first out</strong></li>
<li><strong>Shortest job fist (SJF) - optimizes turnaround time</strong>
<ul>
<li>This new scheduling discipline is known as Shortest Job First (SJF),
and the name should be easy to remember because it describes the policy
quite completely: it runs the shortest job first, then the next
shortest, and so on.</li>
</ul></li>
<li><strong>Shortest time to completion first (STCF) - optimizes
turnaround time</strong>
<ul>
<li>Any time a new job enters the system, the STCF scheduler determines
which of the remaining jobs (including the new job) has the least time
left, and schedules that one. Thus, in our example, STCF would preempt A
and run B and C to completion</li>
</ul></li>
<li><strong>Round robin - optimizes response time</strong>
<ul>
<li>The basic idea is simple: instead of running jobs to completion, RR
runs a job for a time slice (sometimes called a scheduling quantum) and
then switches to the next job in the run queue.</li>
<li>The shorter the time slice the better; deciding on this length is a
trade-off</li>
<li>Any policy (such as RR) that is fair, i.e., that evenly divides the
CPU among active processes on a small time scale, will perform poorly on
metrics such as turnaround time</li>
</ul></li>
</ul>
<p><strong>Metrics</strong>:</p>
<ul>
<li>Response time: time of first run - time of arrival</li>
<li>Turnaround time: time of completion - time of arrival</li>
</ul>
<h3>Scheduling: Multi-Level Feedback Queue</h3>
<p>The Multi-level Feedback Queue (MLFQ) sched- uler was first described
by Corbato et al. in 1962 [C+62] in a system known as the Compatible
Time-Sharing System (CTSS), and this work, along with later work on
Multics, led the ACM to award Corbato its highest honor, the Turing
Award.</p>
<p>It optimizes for turnaround time. Done by running shorter jobs first.
It tries to make the system feel responsive to interactive users.
(minimizing staring at the screen and waiting)</p>
<p><em>Key Question: How do we schedule without perfect
knowledge?</em></p>
<p><strong>MLFQ</strong> varies the priority of a job based on its
observed behavior. If, for example, a job repeatedly relinquishes the
CPU while waiting for input from the keyboard, MLFQ will keep its
priority high, as this is how an interactive process might behave. If,
instead, a job uses the CPU intensively for long periods of time, MLFQ
will reduce its priority. In this way, MLFQ will try to learn about
processes as they run, and thus use the history of the job to predict
its future behavior.</p>
<p>Thus, we arrive at the first two basic rules for MLFQ: • Rule 1: If
Priority(A) &gt; Priority(B), A runs (B doesn’t). • Rule 2: If
Priority(A) = Priority(B), A &amp; B run in RR.</p>
<p><strong>Changing Priorities</strong></p>
<ul>
<li>Rule 3: When a job enters the system, it is placed at the highest
priority (the topmost queue).</li>
<li>Rule 4a: If a job uses up an entire time slice while running, its
priority is reduced (i.e., it moves down one queue).</li>
<li>Rule4b: If it gives up the CPU before the time slice is up; stay at
same priority level</li>
</ul>
<p>Key issues:</p>
<ul>
<li>Starvation; what if we have a LOT of interactive jobs; long-running
CPU jobs will never finish</li>
<li>Gaming the scheduler: sneaky trick to get more time than its fair;
e.g., issue a quick IO before the time slice is up</li>
</ul>
<p><strong>Boosting priorities</strong></p>
<ul>
<li>Rule 5: After some time period S, move all the jobs in the system to
the topmost queue.</li>
</ul>
<p>It guarantees the processes won't starve by sitting in the top queue.
It also shares the CPU with other high priority jobs. If a job becomes
interactive it will receive a proper priority boost.</p>
<p><strong>Add Accounting</strong></p>
<ul>
<li>Rule 4: Once a job uses up its time allotment at a given level (re-
gardless of how many times it has given up the CPU), its priority is
reduced (i.e., it moves down one queue).</li>
</ul>
<p><em>MLFQ is interesting because instead of demanding a priori
knowledge of the nature of a job, it instead observes the execution of a
job and pri- oritizes it accordingly.</em></p>
<h3>Scheduling: Proportional Share</h3>
<p>In this case we want to optimize for each CPU process to obtain a
certain percentage of CPU time.</p>
<p>The key question is how can we degin a scheduler to share the CPU in
a proportional manner.</p>
<p>To solve for this, we can use tickets and randomness. We pull a
number from 0 to 99; assuming process A holds 0 through 74 and B 75
through 99. The winning ticket determies whether A or B runs.</p>
<p>It's not perfect but it will get us to a rough percentage over
time.</p>
<p>Ticket Mechanisms</p>
<ul>
<li>Ticket currency: allow users to allocate tickets among their own
jobs..</li>
<li>Ticket transfer: in client/server settings, allow the client to send
some tickets to the server</li>
<li>Ticket inflation: a process can temporarily raise or lower the
number of ticket it owns. If a process needs more CPU time it can raise
the ticket value to reflect that need to the system</li>
</ul>
<p>Implementation:</p>
<ul>
<li>We can use a linked list</li>
</ul>
<p>head -&gt; job A, tix 100 -&gt; job b, tix 50 -&gt; job c, tix 250
-&gt; null</p>
<p>Keep going over the list with a given tix number and once you go over
pick that job.</p>
<p>Deterministic Scheduling:</p>
<ul>
<li>We can also use "stride scheduling" which is basically representing
each job's stride as the inverse of the number of tickets they hold</li>
<li>At each point we pick the job with the lowest stride number. Then
increase its number. The jobs with the lowest stride (highest tickets)
will run more often</li>
<li>The downside is we have to maintain global state</li>
</ul>
<p>Proportional-share scheduleres are more useful in domains that are
easier to solve. E.g., a virtualized data center where you can assign
CPU cycles to given VMs.</p>
<h2>Virtualization</h2>
<p>Every address generated by a user program is a virtual address. The
OS gives an illusion that it has a large and private memory. It wants to
give programmers the illusion that you have a long contiguous address
space to put the code into data.</p>
<h3>Abstraction: Address Spaces</h3>
<p>Main Question:</p>
<ul>
<li>How can the OS build this abstraction of a private, potentially
large address space for multiple running processes (all sharing memory)
on top of a single, physical memory?</li>
</ul>
<p>Isolation is key in building reliable systems. The OS wants to run
programs independent of each other. If one fails, it wants to prevent
the other ones from failing. Some OS even wall off the OS from others
with microkernels. (compared with monolithic kernel designs)</p>
<p><strong>Goals of virtualizing memory:</strong></p>
<ul>
<li>Transparency - memory visible to the running program</li>
<li>Efficiency - fast processes using little memory; use hardware
support</li>
<li>Protection - protect processes from one another</li>
</ul>
<h3>Memory API</h3>
<p>Correct memory management has been such a problem, in fact, that many
newer languages have support for automatic memory manage- ment. In such
languages, while you call something akin to malloc() to allocate memory
(usually new or something similar to allocate a new object), you never
have to call something to free space; rather, a garbage collector runs
and figures out what memory you no longer have references to and frees
it for you.</p>
<p>Common issues:</p>
<ul>
<li>Forgetting to allocate memory</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>src <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>dst<span class="op">;</span> <span class="co">// oops! unallocated </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>dst<span class="op">,</span> src<span class="op">);</span> <span class="co">// segfault and dieA</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>src <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>dst <span class="op">=</span> <span class="op">(</span><span class="dt">char</span> <span class="op">*)</span> malloc<span class="op">(</span>strlen<span class="op">(</span>src<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>dst<span class="op">,</span> src<span class="op">);</span> <span class="co">// work properly</span></span></code></pre></div>
<ul>
<li>Not allocating enough memory</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>src <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>dst <span class="op">=</span> <span class="op">(</span><span class="dt">char</span> <span class="op">*)</span> malloc<span class="op">(</span>strlen<span class="op">(</span>src<span class="op">));</span> <span class="co">// too small! </span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>strcpy<span class="op">(</span>dst<span class="op">,</span> src<span class="op">);</span> <span class="co">// work properly</span></span></code></pre></div>
<ul>
<li>Forgetting to initialize allocated memory</li>
<li>Forgetting to free memory</li>
<li>Freeing memory before you're done aka dangling pointers</li>
<li>Double freeing memory</li>
</ul>
<p>Good tools to prevent issues: check out both purify [HJ92] and
valgrind [SN05]; both are excellent at helping you locate the source of
your memory-related problems.</p>
<h2>Project 1B</h2>
<p>What are system calls?</p>
<ul>
<li>A call between you and the machine, you call the OS and ask him to
do stuff for you</li>
</ul>
<h3>Virtual Memory: Address Translation</h3>
<p>Address translation implies mapping the virtual addresses to the
physical space. This happens in the kernel space since its a priviledged
operation. If we don't find an address we might get a segmentation
fault.</p>
<p>The most popular method is dynamic relocation which is:</p>
<p><code>physical address = virtual address + base</code></p>
<p>The hardware provides base and bound registers. The hardware needs to
check whether the address is valid. This is done by the base and bounds
register.</p>
<p>The OS also needs to know which areas of memory are free through the
"free list".</p>
<pre><code>ARG seed 0
ARG address space size 1k
ARG phys mem size 64k

Base-and-Bounds register information:

  Base   : 0x00008000 (decimal 32768)
  Limit  : 16384

Virtual Address Trace
  VA  0: 0x00000360 (decimal:  864) --&gt; VALID: 0x00008360 (decimal: 33632)
  VA  1: 0x00000308 (decimal:  776) --&gt; VALID: 0x00008308 (decimal: 33544)
  VA  2: 0x000001ae (decimal:  430) --&gt; VALID: 0x000081ae (decimal: 33198)
  VA  3: 0x00000109 (decimal:  265) --&gt; VALID: 0x00008109 (decimal: 33033)
  VA  4: 0x0000020b (decimal:  523) --&gt; VALID: 0x0000820b (decimal: 33291)</code></pre>
<h2>Segmentation</h2>
<p>Key question: how do we support a large address space with many gaps
between the stack and the heap.</p>
<p>If we segment, we can place each one of the segments in diff parts of
the physical memory avoiding unused virtual address space.</p>
<p>The infamous term segmentation fault arises from a memory access on a
segmented machine to an illegal address.</p>
<p>We can have coarse grained and fine-grained segmentation.</p>
<p>There are many algorithms to minimize external framgentation. Which
means there's not one perfect solution.</p>
<p>There are issues when we try allocating variable-sized segments in
memory. The main one is external fragmentation. Because they get chopped
up it can be hard to allocate the right amount of memory. We also still
may have large segments of unused memory. The heap still needs the full
allotted space to work.</p>
<pre><code>ARG seed 2
ARG address space size 128
ARG phys mem size 1024k

Segment register information:

  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)
  Segment 0 limit                  : 20

  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)
  Segment 1 limit                  : 20

Virtual Address Trace
  VA  0: 0x0000007a (decimal:  122) --&gt; VALID in SEG1: 0x000001fa (decimal:  506)
  VA  1: 0x00000079 (decimal:  121) --&gt; VALID in SEG1: 0x000001f9 (decimal:  505)
  VA  2: 0x00000007 (decimal:    7) --&gt; VALID in SEG0: 0x00000007 (decimal:    7)
  VA  3: 0x0000000a (decimal:   10) --&gt; VALID in SEG0: 0x0000000a (decimal:   10)
  VA  4: 0x0000006a (decimal:  106) --&gt; SEGMENTATION VIOLATION (SEG1)</code></pre>
<p>In the sample address space above. We have 128 bye address spaces
mapped two two segments. Segment 0 is the heap and segment 1 the stack
(grows up). We can only map values it seems that grow from 0 to 20 or
from 128 to 108. Therefore the valid addresses are 0-20 and 108-128. 106
causes a segment violation and it can't be mapped to our memory.</p>
<h3>Free-Space Management</h3>
<p>Key question: how do we manage free space if we're satisfying
variable-sized requests. How do we minimze framentation? What are the
time and space overheads of alternate approaches?</p>
<p>Issues with free space:</p>
<ul>
<li>Fragmenting the memory</li>
</ul>
<p>Strategies to manage free space</p>
<ul>
<li>Best fit: search through the free list, find chunks of free memory
that are as big as the requested size. Then return one that is the
smalles of the group of candidates. "Best fit chunk". We can end up
paying for the exhaustive search.</li>
<li>Worst fit: find the largest chunk, return it, keep the remaining
large chunk on the free list</li>
<li>First fit: return the first big enough chunk</li>
<li>Next fit: keep a pointer to the location within the list where one
was looking last. Avoids exhaustive looking.</li>
</ul>
<p><strong>Segregated lists</strong></p>
<p>If an app has few popular-sized requests that it makes. Keep a
separate list just to manage objects of that size. Anything else send to
a more general allocator. An issue is how much memory do you keep for
this speciall allocator.</p>
<p>To fix this Jeff Bonwick invented the slab allocator. When the kernel
boots up, it allocates object caches for kernel objects requested
frequently. Thus these caches are segregated free lists of a given size
and serve quickly. When they're running low on space they ask for slabs
of memory from the general memory allocator.</p>
<p><strong>Buddy allocation</strong></p>
<p>Memory is thought of as a big space of size 2^N. When the request is
made. THe search divides free space by two until a block that is big
enough can be returned. Then its returned to the user.</p>
<p>When the block is freed. The allocator checks whether the buddy 8KB
is free. If so, it coalesces the blocks. And so on and so forth. It
stops when a buddy is found in use.</p>
<p>There are many trade-offs in these allocators. The more you know
about the workloads, the more you can tune it to work better for that
workload. Making it fast and spece-efficient is still a big
challenge.</p>
<p>In the exercise, we can see how changing the order of the sizes can
speed up searching through the lists. When we use worst fit, and sort in
descending order, the searching is quick. If it was sorted in ascending
order it would take close to O(N).</p>
<p>When we coalesce the list, even if we have a lot of ops, we end up
with a smaller free-list. I assume this would lower the latency of the
process.</p>
<p>When many of the operations were to free vs. allocate we returned
more and less failures in allocating memory. It makes sense, when we run
out of memory we start returning -1 to the malloc() functions.</p>
<h3>Paging: Introduction</h3>
<p>Key question: how do we virtualize memory with pages to avoid the
problems of segmentation.</p>
<h3>The Page Table</h3>
<p>One of the most important data structures in the memory management
subsystem of a modern OS is the page table.</p>
<p>It stores virtual-to-physical address translations. Letting the
system know where each page of an address resides in physical
memory.</p>
<p>Structure of a page table:</p>
<p>PFN | G | PAT | D | A | PCD | PWT | U/S | R/W | P</p>
<ul>
<li>We have a present bit</li>
<li>A reference bit</li>
<li>A read/write bit</li>
<li>A user/supervisor bit</li>
<li>Hardware caching bits</li>
<li>An accessed bit</li>
<li>A dirty bit</li>
<li>And the page-frame-number itself</li>
</ul>
<p><strong>Formula to calculate map from virtual to phyisical
memory</strong></p>
<p>The main page table operation can be exemplified by:</p>
<p><code>movl 21, %eax</code></p>
<p>This means that we're referencing address 21. We want to translate
virtual address 21 into the proper address 117. To do so we need to run
the instructions below to find the physical address.</p>
<p>To find the location of the desired page table entry.</p>
<pre><code>// Extract the VPN from the virtual address
VPN = (virtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT

// Form the address of the PTE
PTEAddr = PageTableBase Register + (VPN * sizeof(PTE))</code></pre>
<p>In the example above shift is 4 (number of bits in the1 offset).
Assuming we have a virtual address 21 (010101); the masking turns this
value into 010000; the shift turns it into 01 which would be the virtual
page 1.</p>
<p>We then use this value to index the array of PTEs.</p>
<pre><code>// Access is OK, form the physical address and fetch it
offset = virtual address &amp; offset mask
physical address = (PFN &lt;&lt; shift) | offset</code></pre>
<p>With this physical address, the hardware can fetch the desired data
from memory and put it into register eax.</p>
<p>Summary code:</p>
<pre><code>// Extract the VPN from the virtual address
VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT

// Form the address of the page-table entry (PTE)
PTEAddr = PTBR + (VPN * sizeof(PTE))

// Fetch the PTE
PTE = AccessMemory(PTEAddr)

// Check if process can access the page
if (PTE.Valid == False)
    RaiseException(SEGMENTATION_FAULT)
else if (CanAccess(PTE.ProtectBits) == False)
    RaiseException(PROTECTION_FAULT)
else
// Access is OK: form physical address and fetch it
offset = VirtualAddress &amp; OFFSET_MASK
PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset
Register = AccessMemory(PhysAddr)</code></pre>
<p><strong>Example translation</strong></p>
<p>Virtual Address 4: 0x00003a1e (Decimal: 14878)</p>
<p><strong>Extract VPN and Offset:</strong></p>
<ul>
<li>Hexadecimal 0x3a1e to binary is 11 1010 0001 1110.</li>
<li>VPN: Top 2 bits → 11 (binary) → 3 (decimal).</li>
<li>Offset: Lower 12 bits → 1010 0001 1110 → 0xa1e (hex).</li>
</ul>
<p><strong>Check Page Table for VPN 3:</strong></p>
<ul>
<li>Entry: 0x80000006 (Valid, PFN = 6).</li>
</ul>
<p><strong>Calculate Physical Address:</strong></p>
<ul>
<li>PFN 6 to base address: 6 * 4096 = 24576 or 0x6000.</li>
<li>Physical Address: 0x6000 + 0xa1e = 0x6a1e.</li>
</ul>
<h3>Reflection questions</h3>
<p>What happens as address space grows?</p>
<ul>
<li>We get more potential page tables</li>
</ul>
<p>What happens as we increase page size?</p>
<ul>
<li>We get less page tables; bigger ones</li>
</ul>
<p>Why not use big page sizes in general?</p>
<ul>
<li>As we increase the size of the pages, we get less pages in the page
table entry.</li>
<li>The bigger the tables the more fragmentation.</li>
<li>Bigger pages mean smaller processes must still be allocated a full
large page.</li>
<li>Larger pages can reduce the effectiveness of cache systems. Ihey can
decrease the locality of reference.</li>
<li>When page fault occur, the system must load the required page from
disk. Larger pages means more transferred data per page fault, which can
slow down the response time</li>
</ul>
<p>What happens as you increase the percentage of pages that are
allocated in each address space?</p>
<ul>
<li>We suffer more page faults because the physical memory is busy</li>
<li>The system might have to swap pages in and out more frequently</li>
</ul>
<h3>Paging: Faster Translations</h3>
<p>Key question: how can we speed up address translation, and generally
avoid the extra memory reference that paging seems to require? What kind
of hardware support do we need?</p>
<p>To speed up translations we use a cache. We call it the
translation-lookaside buffer (TLB). It is simply a hardware cache of
popular translations. A better name would be an address-translation
cache.</p>
<p>Example algorithm:</p>
<pre><code>VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
if (Success == True)   // TLB Hit
    if (CanAccess(TlbEntry.ProtectBits) == True)
        Offset   = VirtualAddress &amp; OFFSET_MASK
        PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset
        Register = AccessMemory(PhysAddr)
    else
        RaiseException(PROTECTION_FAULT)
else                  // TLB Miss
    PTEAddr = PTBR + (VPN * sizeof(PTE))
    PTE = AccessMemory(PTEAddr)
    if (PTE.Valid == False)
        RaiseException(SEGMENTATION_FAULT)
    else if (CanAccess(PTE.ProtectBits) == False)
        RaiseException(PROTECTION_FAULT)
    else
        TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
        RetryInstruction()</code></pre>
<p><strong>Caching</strong></p>
<p>Caching is an important principle of this process. It relies on
spatial locality and temporal locality. Spatial locality means if a
program accesses memory in an area X, it might access areas nearby in
the future. Temporal locality means if an instruction is commonly
accessed, it might be re-accessed again in the future.</p>
<p>All of this relies on the cache being small. Once we try to grow it
too much we will have the same issues of accessing other types of
memory.</p>
<p><strong>Who handles TLB misses?</strong></p>
<p>Hardware and software people didn't trust each other. Thus the
hardware sometimes would handle the TLB miss entirely.</p>
<p>Most architectures now (RISC) handle the TLB with a software-managed
TLB. On a TLB miss, the hardware raises an exception, which pauses the
instruction stream, raises the priviledge to kernel mode and jumps to a
trap handler.</p>
<p><strong>RISC vs. CISC</strong></p>
<p>There used to be two camps. Complex Instruction Set Comptuing (CISC)
and Reduced ISC.</p>
<p>CISC sets had a lot of instructions in them; each one was really
powerful. The idea was that instructions should be high-level
primitives, to make the assembly language easier to use.</p>
<p>RISC are the opposite. They argued to rip out as much hardware as
possible and make whats left really fast. RISC chips were faster and
MIPS and Sun were started out of it.</p>
<p>Intel then started making their CISC chips faster and now we have
both combinations.</p>
<p><strong>TLB Contents</strong></p>
<p>TLBs might have 32, 64, or 128 entires.</p>
<p>VPN | PFN | other bits</p>
<p>Key question: how do we handle the TLB during context switches?</p>
<p>A potential solution is to flush it every time. But this will be
costly because then we need to incur new TLB misses until it is
refreshed.</p>
<p>Another solution can be adding an identifier to the process that's
using each entry. This is known as the Address Space Identifier (ASID).
Similar to a process identifier but with fewer bits.</p>
<p><strong>Issue: Replacement Policies</strong></p>
<p>What happens when we need to replace a TLB entry? we can use the
Least Recently Used method or a random method. Each one has its pros and
cons. The LRU can behave unreasonably in certain occassions; so the
random one might avoid edge cases in other times.</p>
<p><strong>Reflection questions:</strong></p>
<ul>
<li>Why do we use TLBs when managing address translations?</li>
<li>What happens if we didn't have TLBs?</li>
<li>How do we deal with TLBs across different processes?</li>
<li>What's the max amount of entries and mappings a TLB could
handle?</li>
</ul>
<h2>Paging: Smaller Tables</h2>
<p>Key question: how to make page tables smaller? Linear page tables are
too big; taking up far too much memory on typical systems. How can we
make them smaller?</p>
<p>If we make them too big, we have internal fragmentation. Often we
just end up using 4KB and 8KB pages.</p>
<p>E.g., If we have a page table for a 16KB address space with 1KB
pages; we might have 3-4 used pages but the other ones might be
empty.</p>
<h3>Multi-Level Page Table</h3>
<p>We use a page directory that points to each page table. Each entry in
this page diretory has a valid bit and a page frame number. The valid
bit indicates if any of the entries in the page table it points to is
valid.</p>
<pre><code>PDE (Page Directory Entries)
  Valid Bit -&gt; Tell us if the page table has any valid entries
  Page Frame Number -&gt; Points to the page table

Page Table
  Valid Bit
  Protection
  Page Frame Number

Page frame (X bits of info)
  Contains the a set of bits with information on the process

Page-Directory Entry:
PDEAddr = PageDirBase + (PDIndex + sizeof(PDE))
PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))</code></pre>
<h3>Tip</h3>
<p>Be wary of design trade-offs. Always implement the least complex
system that achieves the task at hand. Avoid needless complexity, in
prematurely-optimized code or other forms. It makes it harder to
understand, maintain and debug the code.</p>
<p>Reflection question:</p>
<ul>
<li>Why do we use page tables in the first place: they're used to
translate virtual to physical addresses. If the page table is too small
we might have collissions?</li>
<li>How do address translations work in multi-level page entries</li>
<li>What are the time-space trade-offs of linear page tables vs.
multi-level page tables</li>
</ul>
<h2>Beyond Physical Memory: Mechanisms</h2>
<p>General page mechanism:</p>
<ul>
<li>The hardware extracts the VPN (virtual page number) from the virtual
address</li>
<li>It then checks the TLB (dictionary cache) for a match; if its a hit,
it return the physical address</li>
<li>If not, it looks up the page table in memory (using the page table
base register) and looks up the entry (page table entry) using the VPN
as the index</li>
<li>If the table is valid and present, we extract the page frame number,
add it to the cache, and retry generating a cache hit next time</li>
</ul>
<p>What if we try to access the page but its not in memory? It is
normally determined through a "present bit". If its set to 1, we're
good. If not (its on the disk) then we we cause a <strong>page
fault</strong></p>
<p>The page fault is handled by a <strong>page fault handler</strong>
which is in the software.</p>
<p>If the page is not present, and has been swapped to disk. The OS is
going to <em>swap</em> the page into memory to service the page fault.
It will use the PTE to find the addrtess and issue the request to the
disk.</p>
<p><strong>What if the OS is full?</strong></p>
<p>We then need to replace the page. Here comes the page replacement
policy.</p>
<pre><code> PFN = FindFreePhysicalPage()
// no free page found
2 if (PFN == -1)
    // run replacement algorithm
    3 PFN = EvictPage()
// sleep (waiting for I/O)
4 DiskRead(PTE.DiskAddr, PFN)
// update page table with present
5 PTE.present = True
// bit and translation (PFN)
6 PTE.PFN = PFN
7 RetryInstruction()</code></pre>
<p>To keep the memory free the OS has a low and high watermark. It
proactively evicts tables until we have a certain amount of free pages.
This is done by the page daemon.</p>
<p>Key questions:</p>
<ul>
<li>What type of storage devices are easier or faster to swap
spaces?</li>
<li>What happens when a program needs to access memory?</li>
</ul>
<h2>Beyond Physical Memory: Policies</h2>
<p><strong>Key question</strong>: what page do we evict when we run out
of memory?</p>
<p>We want to maximize the amount of cache hits. Number of times a page
can be accessed in memory.</p>
<p>We use the "Average Memory Access Time"</p>
<p>$AMAT = T_M + P_{Miss} * T_D$</p>
<p>TM represents the cost of accessing memory, TD the cost of ac-
cessing disk, and PMiss the probability of not finding the data in the
cache (a miss); PMiss varies from 0.0 to 1.0,</p>
<p><strong>What is the optimal policy?</strong></p>
<p>Replace the page that will be accessed the furthest in the future.
Resulting in the fewest cache misses.</p>
<p>There are 3 types of cache misses (Three Cs)</p>
<ul>
<li><strong>Compulsory miss aka cold start miss</strong>: it occurs
because it was empty to being with and you need to add it</li>
<li><strong>Capacity miss</strong>: the cache ran out of space and had
to evict an item to bring a new one to the cache</li>
<li><strong>Conflict miss</strong>: no space available. Doesn't have in
OS page cache because there's no restrictions where can put a page.</li>
</ul>
<p><strong>Simpler Policy: FIFO</strong></p>
<p>We evict the caches in order. It doesn't perform as well as the
optimal more complicated policy. Pages are placed in a queue when they
enter the system. When we need to replace we evict the page at the end
of the queue.</p>
<p><strong>Another Simple Policy: Random</strong></p>
<p>Simply picks a random page to replace under memory pressure. Can do
better or worst. But simple to implement.</p>
<p><strong>Usage History Policy: LRU</strong></p>
<p>A more commonly- used property of a page is its
<strong>recency</strong> of access; the more recently a page has been
accessed, perhaps the more likely it will be accessed again.</p>
<p>This is based on the "principle of locality". Programs tend to access
certain code and data structures frequently. We should use history to
figure out which pages are important and keep them.</p>
<p>We then have Least Frequently Used and Least Recently Used.</p>
<p><strong>Types of Locality</strong></p>
<ul>
<li>Spatial: pages around a given page will be accessed more
frequently</li>
<li>Temporal: pages accessed often will be accessed again</li>
</ul>
<p>The performance of each policy will vary based on the workload.</p>
<ul>
<li>Random workload: they all perform about the same.</li>
<li>80/20 workload (some memories get accessed more often): LRU and the
Optimal perform better than FIFO and Random</li>
<li>Looping workload (for loop): OPT and LRU perform better but random
performs not too bad.</li>
</ul>
<h2>Virtualization Key Concepts</h2>
<ul>
<li>What is a system call and how does it work?</li>
<li>What is a context switch?</li>
<li>What are some common process scheduling algorithms?</li>
<li>How does a process reserve memory?</li>
<li>What are the different ways in which memory can be stored?
(Segmentation and paging)</li>
<li>How does segmentation work?</li>
<li>What is the free-space management problem in memory allocation?</li>
<li>What is the principle of locality in caching?</li>
<li>How does paging work?</li>
<li>What are page replacement algorithms and why are they
necessary?</li>
<li>How does the system map virtual memory to physical memory?</li>
<li>What happens when the OS runs out of memory?</li>
<li>What happens if we have huge page tables? What are the drawbacks?
<ul>
<li>e.g., Internal fragmentation</li>
</ul></li>
<li>How do page tables work?</li>
<li>What are the different types of page tables?</li>
<li>How are multi-level page tables better than linear ones?</li>
<li>What is a TLB? When is it used?</li>
<li>What happens during TLB misses?</li>
<li>What are some policies we use to replace cache in TLBs?</li>
<li>How do segmentation fault occurs?</li>
</ul>
<h1>Phase 2: Concurrency</h1>
<h2>Introduction to Concurrency</h2>
<p>Concurrency is great because it allows us to do parallel programming
and to run the program while we wait for I/O operations.</p>
<p>Concurrency is harder than single-threaded programs because we now
have to manage shared data and state across threads.</p>
<p>We can run into issues such as data races and deadlocking among
others.</p>
<p>To solve for this, Dijkstra invented atomic operations and sync
primitives that allow us to give some guarantees to the program.</p>
<p>An example is sempahores. They guarantee at most N threads will pass
through a critical section.</p>
<p>Another example is incrementing a counter with two threads, if we
don't use sync primitives we may run into an indeterministic program.
i.e., run it twice and get different results.</p>
<p>The most important questions are:</p>
<ul>
<li>What support do we need from the hardware in order to build useful
synchronization primitives?</li>
<li>What support do we need from the OS?</li>
<li>How can we build these primitives correctly and efficiently?</li>
<li>How can programs use them to get the desired results?</li>
</ul>
<p>The key terms are:</p>
<ul>
<li>A critical section: two threads accessing a shared resource</li>
<li>A race condition: two threads targeting a critical section</li>
<li>An indeterminate program vs. indeterminate: random vs. not</li>
<li>Mutual exclusion primitives: 1 single thread ever entering critical
sections</li>
</ul>
<p>An useful tool to validate threads in C is helgrind, run it with
<code>valgrind --tool=helgrind ./main-signal-cv</code></p>
<h2>Thread APIs</h2>
<ul>
<li>pthread_create()</li>
<li>pthread_join()</li>
<li>pthread_mutex_lock(&amp;lock);</li>
<li>pthread_mutex_unlock(&amp;lock);</li>
<li>pthread_cond(&amp;lock);</li>
</ul>
<h2>Locks</h2>
<p>Key Question:</p>
<ul>
<li>How do we build an efficient lock? It should provide mutual
exclusion at a low cost</li>
<li>How does each lock work? Can you explain the principles of each lock
and why do we use it?</li>
<li>What are the most used locks in practice?</li>
<li>How do we measure the CPU impact of different types of locks?</li>
</ul>
<p>A good lock should provide:</p>
<ul>
<li>Fairness</li>
<li>Mutual exclusion</li>
<li>No starvation</li>
<li>Performance (as low overhead as possible)</li>
</ul>
<p>Locks can have hardware support and OS support to run properly. To
build a good lock we need to assume a little hardware support. That way
we can meet all the properties above.</p>
<h3>Spin lock using Test-and-set</h3>
<p>As long as the lock is held by another thread, TestAndSet() will
repeatedly return 1, and thus this thread will spin and spin until the
lock is finally released.</p>
<pre><code>typedef struct __lock_t {
    int flag;

void init(lock_t *lock) {
    // 0: lock is available, 1: lock is held
    lock-&gt;flag = 0;
}

void lock(lock_t *lock) {
        // It tests the old value while simultaneously sets it to
        // a new value
    while (TestAndSet(&amp;lock-&gt;flag, 1) == 1)
        ; // spin-wait (do nothing)
}
void unlock(lock_t *lock) {
    lock-&gt;flag = 0;
}</code></pre>
<h3>Compare-And-Swap</h3>
<p>Checks if the value at an address is expected, if so updates it with
a new value.</p>
<pre><code>   void lock(lock_t *lock) {
          while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1)
                    ; // spin</code></pre>
<h3>Load-Linked and Store-Conditional</h3>
<ul>
<li><strong>Load-Linked</strong>: fetches a value from memory and places
it in a register</li>
<li><strong>Store-Conditional</strong>: only succeeds if no intervening
store to the address has taken place</li>
</ul>
<p>Potential lock:</p>
<ul>
<li>We fetch a value from memory</li>
<li>Only succeed if no store has taken place</li>
</ul>
<p>If there's not a value stored in memory keep rotating.</p>
<p>E.g.,</p>
<pre><code>int LoadLinked(int *ptr) {
    return *ptr;
}

int StoreConditional(int *ptr, int value) {
    if (no update to *ptr since LoadLinked to this address) {
        *ptr = value;
        return 1; // success!
    } else {
        return 0; // failed to update
    }
}

void lock(lock_t *lock) {
       while (1) {
           while (LoadLinked(&amp;lock-&gt;flag) == 1)
               ; // spin until it’s zero
           if (StoreConditional(&amp;lock-&gt;flag, 1) == 1)
               // if set-it-to-1 was a success: all done
               // otherwise: try it all over again
               return; 
   
   void unlock(lock_t *lock) {
       lock-&gt;flag = 0;
    }</code></pre>
<h3>Fetch-And-Add</h3>
<pre><code>int FetchAndAdd(int *ptr) {
    int old = *ptr;
    *ptr = old + 1;
    return old;
}

typedef struct __lock_t {
    int ticket;
    int turn;
} lock_t;


void lock_init(lock_t *lock) {
    lock-&gt;ticket = 0;
    lock-&gt;turn = 0;
}

void lock(lock_t *lock) {
    int myturn = FetchAndAdd(&amp;lock-&gt;ticket);
    while (lock-&gt;turn != myturn)
        ; // spin
}

void unlock(lock_t *lock) {
    lock-&gt;turn = lock-&gt;turn + 1;
}</code></pre>
<h3>OS Support</h3>
<p>In the case of some locks, the OS can allows us to yield or park
certain threads. This works well in some cases.</p>
<p>Yield lets us yield the CPU to other threads while our current thread
is blocked.</p>
<p>Park allows us to put a calling thread to sleep and unpack to wake it
up by its <code>threadID</code></p>
<h2>Lock-Based Concurrent Data Structures</h2>
<h2>Conditional Variables</h2>
<p>Key questions:</p>
<ul>
<li>How can we make a thread wait based on some condition? In a way that
is efficient and doesn't waste CPU cycles?</li>
</ul>
<p><strong>Condition variables</strong> A condition variable has two
operations associated with it: wait() and signal()</p>
<p>E.g.,</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> done  <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>pthread_mutex_t m <span class="op">=</span> PTHREAD_MUTEX_INITIALIZER<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>pthread_cond_t c  <span class="op">=</span> PTHREAD_COND_INITIALIZER<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> thr_exit<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    Pthread_mutex_lock<span class="op">(&amp;</span>m<span class="op">);</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    done <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    Pthread_cond_signal<span class="op">(&amp;</span>c<span class="op">);</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    Pthread_mutex_unlock<span class="op">(&amp;</span>m<span class="op">);</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>child<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;child</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    thr_exit<span class="op">();</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> thr_join<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    Pthread_mutex_lock<span class="op">(&amp;</span>m<span class="op">);</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>done <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        Pthread_cond_wait<span class="op">(&amp;</span>c<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    Pthread_mutex_unlock<span class="op">(&amp;</span>m<span class="op">);</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="dt">int</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;parent: begin</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    pthread_t p<span class="op">;</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    Pthread_create<span class="op">(&amp;</span>p<span class="op">,</span> NULL<span class="op">,</span> child<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    thr_join<span class="op">();</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;parent: end</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Note:</strong></p>
<ul>
<li>Although it is strictly not necessary in all cases, it is likely
simplest and best to hold the lock while signaling when using condition
variables.</li>
<li>Always use while loops with conditional variables (Mesa semantics);
you want to re-check the condition</li>
</ul>
<h3>Semaphores</h3>
<p><strong>Key question</strong></p>
<ul>
<li>How can we use semaphores instead of locks and condition variables?
What is a semaphore and how do we use it?</li>
</ul>
<blockquote>
<p>A semaphore is an object with an integer value that we can manipulate
with two routines; in the POSIX standard, these routines are sem wait()
and sem post()</p>
</blockquote>
<p><code>sem_wait(s)</code>: decrements the value of semaphore s by one,
wait if the value is negative</p>
<p><code>sem_post(s)</code>: increments value of s by one, if there are
threads waiting, wake one</p>
<p><strong>Binary Semaphores</strong></p>
<p>\We can have multiple types of semaphores, an example of one is a
<code>Binary Semaphore</code> which acts as a lock.</p>
<p><strong>Semaphores for Ordering</strong></p>
<p>We can also use semaphores to have a parent wait for its child to
run. To do this, we set <code>s</code> as 0.</p>
<p>![[Pasted image 20240625101238.png|500]]</p>
<p><strong>Producer/Consumer Problem</strong></p>
<blockquote>
<p>One simple way to think about it, thanks to Perry Kivolowitz, is to
consider the <strong>number of resources you are willing to give away
immediately after initialization.</strong> With the lock, it was 1,
because you are willing to have the lock locked (given away) immediately
after initialization. With the ordering case, it was 0, because there is
nothing to give away at the start; only when the child thread is done is
the resource created, at which point, the value is incremented to 1. Try
this line of thinking on future semaphore problems, and see if it
helps.</p>
</blockquote>
<p>We can use multiple semaphores to add mutual exclusion.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>producer<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> loops<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        sem_wait<span class="op">(&amp;</span>empty<span class="op">);</span>   <span class="co">// Wait for empty slot</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        sem_wait<span class="op">(&amp;</span>mutex<span class="op">);</span>   <span class="co">// Enter critical section</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        put<span class="op">(</span>i<span class="op">);</span>             <span class="co">// Put item in the buffer</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        sem_post<span class="op">(&amp;</span>mutex<span class="op">);</span>   <span class="co">// Leave critical section</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        sem_post<span class="op">(&amp;</span>full<span class="op">);</span>    <span class="co">// Increment count of full slots</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>consumer<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> tmp<span class="op">;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> loops<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        sem_wait<span class="op">(&amp;</span>full<span class="op">);</span>    <span class="co">// Wait for full slot</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        sem_wait<span class="op">(&amp;</span>mutex<span class="op">);</span>   <span class="co">// Enter critical section</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        tmp <span class="op">=</span> get<span class="op">();</span>        <span class="co">// Get item from the buffer</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        sem_post<span class="op">(&amp;</span>mutex<span class="op">);</span>   <span class="co">// Leave critical section</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        sem_post<span class="op">(&amp;</span>empty<span class="op">);</span>   <span class="co">// Increment count of empty slots</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> tmp<span class="op">);</span> <span class="co">// Print the consumed item</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Reader-Writer Locks</strong></p>
<p>Reader-writer locks allow us to have multiple readers (threads)
accessing a critical section to read data. If there's a writer modifying
the shared data we won't allow readers to access this section.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> _rwlock_t <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  sem_t lock<span class="op">;</span>      <span class="co">// binary semaphore (basic lock)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  sem_t writelock<span class="op">;</span> <span class="co">// allow ONE writer/MANY readers</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>   readers<span class="op">;</span>   <span class="co">// #readers in critical section</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  rwlock_t<span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rwlock_init<span class="op">(</span>rwlock_t <span class="op">*</span>rw<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  rw<span class="op">-&gt;</span>readers <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  sem_init<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>lock<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  sem_init<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>writelock<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rwlock_acquire_readlock<span class="op">(</span>rwlock_t <span class="op">*</span>rw<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>  sem_wait<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>lock<span class="op">);</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>  rw<span class="op">-&gt;</span>readers<span class="op">++;</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>rw<span class="op">-&gt;</span>readers <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="co">// first reader gets writelock</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    sem_wait<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>writelock<span class="op">);</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  sem_post<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>lock<span class="op">);</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rwlock_release_readlock<span class="op">(</span>rwlock_t <span class="op">*</span>rw<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>  sem_wait<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>lock<span class="op">);</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>  rw<span class="op">-&gt;</span>readers<span class="op">--;</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>rw<span class="op">-&gt;</span>readers <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="co">// last reader lets it go</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    sem_post<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>writelock<span class="op">);</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>  sem_post<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>lock<span class="op">);</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rwlock_acquire_writelock<span class="op">(</span>rwlock_t <span class="op">*</span>rw<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>  sem_wait<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>writelock<span class="op">);</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rwlock_release_writelock<span class="op">(</span>rwlock_t <span class="op">*</span>rw<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>  sem_post<span class="op">(&amp;</span>rw<span class="op">-&gt;</span>writelock<span class="op">);</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3>Common Concurrency Bugs</h3>
<p>Key question:</p>
<ul>
<li>How to recognize and prevent common bugs?</li>
</ul>
<h4>Non-Deadlocks</h4>
<p><strong>Atomicity Violations</strong></p>
<p>One thread tries to access a shared variable before the other. To fix
it, we need to add mutex around the critical sections.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">1</span><span class="op">::</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>thd<span class="op">-&gt;</span>proc_info<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    fputs<span class="op">(</span>thd<span class="op">-&gt;</span>proc_info<span class="op">,...)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">2</span><span class="op">::</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>thd<span class="op">-&gt;</span>proc_info <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>pthread_mutex_t proc_info_lock <span class="op">=</span> PTHREAD_MUTEX_INITIALIZER<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">1</span><span class="op">::</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>pthread_mutex_lock<span class="op">(&amp;</span>proc_info_lock<span class="op">);</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>thd<span class="op">-&gt;</span>proc_info<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    fputs<span class="op">(</span>thd<span class="op">-&gt;</span>proc_info<span class="op">,</span> <span class="op">...);</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>pthread_mutex_unlock<span class="op">(&amp;</span>proc_info_lock<span class="op">);</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">2</span><span class="op">::</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>pthread_mutex_lock<span class="op">(&amp;</span>proc_info_lock<span class="op">);</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>thd<span class="op">-&gt;</span>proc_info <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>pthread_mutex_unlock<span class="op">(&amp;</span>proc_info_lock<span class="op">);</span></span></code></pre></div>
<p><strong>Ordering Violations</strong></p>
<p>Threads depend on each other and one thread might run before the
other. Thread 2 will fail if it runs first.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">1</span><span class="op">::</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    mthread <span class="op">=</span> create_thread<span class="op">()</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">2</span><span class="op">::</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mMain<span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    m_state <span class="op">=</span> mthread<span class="op">-&gt;</span>state</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We need to initialize conditional variables and mutex to allow the
first thread to run first.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>pthread_mutex_t mtLock <span class="op">=</span> PTHREAD_MUTEX_INITIALIZER<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>pthread_cond_t  mtCond <span class="op">=</span> PTHREAD_COND_INITIALIZER<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mtInit <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">1</span><span class="op">::</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    mThread <span class="op">=</span> PR_CreateThread<span class="op">(</span>mMain<span class="op">,</span> <span class="op">...);</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// signal that the thread has been created...</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_lock<span class="op">(&amp;</span>mtLock<span class="op">);</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    mtInit <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    pthread_cond_signal<span class="op">(&amp;</span>mtCond<span class="op">);</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_unlock<span class="op">(&amp;</span>mtLock<span class="op">);</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>Thread <span class="dv">2</span><span class="op">::</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mMain<span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// wait for the thread to be initialized...</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_lock<span class="op">(&amp;</span>mtLock<span class="op">);</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>mtInit <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        pthread_cond_wait<span class="op">(&amp;</span>mtCond<span class="op">,</span> <span class="op">&amp;</span>mtLock<span class="op">);</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_unlock<span class="op">(&amp;</span>mtLock<span class="op">);</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    mState <span class="op">=</span> mThread<span class="op">-&gt;</span>State<span class="op">;</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4>Deadlock Bugs</h4>
<p>Conditions for deadlocks are:</p>
<ul>
<li>Mutual exclusion</li>
<li>Hold and wait</li>
<li>No preemption</li>
<li>Circular wait</li>
</ul>
<p><em>If any of these four conditions are not met, deadlock cannot
occur.</em></p>
<p><strong>How to prevent the common deadlocks?</strong></p>
<p><strong>Circular wait</strong> Use total ordering or partial
ordering: acquire one lock before the other</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>m1 <span class="op">&gt;</span> m2<span class="op">)</span> <span class="op">{</span> <span class="co">// grab in high-to-low address order</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>       pthread_mutex_lock<span class="op">(</span>m1<span class="op">);</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>       pthread_mutex_lock<span class="op">(</span>m2<span class="op">);</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>       pthread_mutex_lock<span class="op">(</span>m2<span class="op">);</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>       pthread_mutex_lock<span class="op">(</span>m1<span class="op">);</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span></code></pre></div>
<p><strong>Hold-and-wait</strong> The hold-and-wait requirement for
deadlock can be avoided by acquiring all locks at once, atomically.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>pthread_mutex_lock<span class="op">(</span>prevention<span class="op">);</span> <span class="co">// begin acquisition</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>pthread_mutex_lock<span class="op">(</span>L1<span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>pthread_mutex_lock<span class="op">(</span>L2<span class="op">);</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>pthread_mutex_unlock<span class="op">(</span>prevention<span class="op">);</span> <span class="co">// end</span></span></code></pre></div>
<p><strong>No preemption</strong> Keep trying to grab the lock
constantly.</p>
<p>Big issue, a <strong>live-lock</strong>.Two threads could both be
repeatedly attempting this sequence and repeatedly failing to acquire
both locks. In this case, both systems are running through this code
sequence over and over again (and thus it is not a deadlock), but
progress is not being made, hence the name livelock</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>top<span class="op">:</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_lock<span class="op">(</span>L1<span class="op">)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pthread_mutex_trylock<span class="op">(</span>L2<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        pthread_mutex_unlock<span class="op">(</span>L1<span class="op">);</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> top<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><strong>Mutual exclusion</strong> Use a lock-free or wait-free
approach. Use compare-and-swap instructions.</p>
<p><strong>Steps:</strong></p>
<ul>
<li>Read the value at the target memory address</li>
<li>Compare it with an expected value</li>
<li>If equal, swap it with a new value</li>
<li>If not equal, do nothing</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> CompareAndSwap<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>address<span class="op">,</span> <span class="dt">int</span> expected<span class="op">,</span> <span class="dt">int</span> new<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>address <span class="op">==</span> expected<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>address<span class="op">=</span>new<span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Scheduling</strong>: used in small hardware OS where we know
the tasks ahead of time. <strong>Detect and recover:</strong> used in
databases; they run periodical deadlock detectors for cycles.</p>
<h3>Event-Based Concurrency</h3>
<blockquote>
<p>How can we build a concurrent server without using threads, and thus
retain control over concurrency as well as avoid some of the problems
that seem to plague multi-threaded applications?</p>
</blockquote>
<p>We can use functions such as <code>select()</code> or
<code>poll()</code> to constantly check for updates on a given
event.</p>
<p>We do this on an event loop: <code>while (1)</code></p>
<p>Handling events has challenges:</p>
<ul>
<li>Handling state (you don't have a stack): we have to manually manage
the stack.</li>
<li>Handling blocking system calls (the event loop would sit idle)</li>
<li>If you have more than 1 CPU, you need to handle multiple event
handlers</li>
<li>Page faults are harder to handle. They will block the server until
the page fault completes</li>
<li>Hard to manage over time. The semantics of the routine might
change.</li>
</ul>
<h1>File Systems</h1>
<h2>I/O Devices</h2>
<p><strong>Key questions</strong></p>
<ul>
<li>How should I/O be integrated into our systems? What should be the
ideal mechanism?</li>
<li>How can the OS check device status without frequent polling?
Lowering CPU overhead to manage the device?</li>
<li>How to lower PIO overheads? i.e., spending too much time moving data
to and from the devices by hand.
<ul>
<li>How can we offload this work?</li>
</ul></li>
<li>How should hardware communicate with devices? Explicitly? Or
abstracting?</li>
<li>How can we build a device-neutral OS? Hide t he device
interactions?</li>
</ul>
<p><strong>System architecture</strong> In a traditional diagrams we
have a CPU attached to the main memory via some kind of memory bus. They
connect via a general I/O bus. Lower down we have peripheral buses too,
such as SCSI, SATA, and USB. They connect to slower devices such as
disks, mice and keyboard.</p>
<p>![[Pasted image 20240708193837.png|400]]</p>
<p>The faster the bus is, the shorter it must be. We put high
performance components closer to the CPU.</p>
<p>Modern systems put the components close to the CPU.</p>
<p>![[Pasted image 20240708193953.png|500]].</p>
<h3>Devices</h3>
<p>A canonical device needs the following.</p>
<p>![[Pasted image 20240708194121.png|500]]</p>
<p>A typical OS interaction will be like this.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a> While <span class="op">(</span>STATUS <span class="op">==</span> BUSY<span class="op">)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>       <span class="op">;</span> <span class="co">// wait until device is not busy</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>   Write data to DATA <span class="dt">register</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>   Write command to COMMAND <span class="dt">register</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>       <span class="op">(</span>starts the device and executes the command<span class="op">)</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>   While <span class="op">(</span>STATUS <span class="op">==</span> BUSY<span class="op">)</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>       <span class="op">;</span> <span class="co">// wait until device is done with your request</span></span></code></pre></div>
<p>The OS waits until the device receives a command by polling it. The
CPU sometimes will send data to the device via programmed I/O (PIO). The
OS will write a command to the register. Finally, the OS will wait for
the device to finish by polling in a loop.</p>
<p>Polling takes a lot of time, so we enable
<strong>interrupts</strong>.</p>
<p>The interrupt will stop the I/O to run other operations. This is best
for slower processes, if we have a fast I/O process we might slow down
the overall performance of the system.</p>
<p>Sometimes we can do a hybrid approach. Use polling and interrupts.
This allows to us to prevent <strong>live-locks</strong>.</p>
<p><strong>Moving data efficiently with Direct Memory Access
(DMA)</strong></p>
<p>A DMA engine is a device tailored to orchestrate transfers between
devices and main memory without the CPU. It's like another machine that
does the transfer if you give it instructions, freeing the CPU.</p>
<p><strong>How to fit devices into an OS?</strong></p>
<p>We use device drivers. This is actual code in the OS to map to have
instructions on how to access the specific device. They involve most of
the code in modern OS's, 70% of the lines of code in Linux.</p>
<p>With proper mapping, we can make the device feel as if it was part of
the file system.</p>
<p>![[Pasted image 20240708195259.png|500]]</p>
<h2>Hard Disk Drives</h2>
<p>Key questions:</p>
<ul>
<li>How do modern hard-disk drives store data? What is the interface?
How is the data actually laid out and accessed? How does disk scheduling
improve performance?</li>
<li>How can we implement SSTF-like scheduling but avoid starvation?</li>
<li>How can we implement an algorithm that more closely approximates SJF
by taking both seek and rotation into account?</li>
</ul>
<p>Tips:</p>
<ul>
<li>Use disks sequentially: transfer data in a sequential manner or in
large chunks; avoid small I/O ops at all costs</li>
<li>Almost any question can be answered with “it depends”, as our
colleague Miron Livny always says. However, use with caution, as if you
answer too many questions this way, people will stop asking you
questions alto- gether.</li>
</ul>
<p>![[Pasted image 20240710101857.png]]</p>
<h2>Redundant Array of Inexpensive Disks (RAIDs)</h2>
<p>Key questions:</p>
<ul>
<li>What are RAIDs?</li>
<li>What are they used for?</li>
<li>What are the different levels?</li>
<li>What kind of applications benefit from each level?</li>
<li>What are software vs. hardware RAIDs?</li>
<li>What are the design considerations when it comes to RAIDs?</li>
</ul>
<h2>Files and Directories</h2>
<p>Key questions:</p>
<ul>
<li>How should the OS manage a persistent device? What are the
APIs?</li>
</ul>
<p>A file is just a linear array of bytes, each of which you can read or
write. Each file has a low-level name. It is often referred as inode
number.</p>
<h3>Files &amp; Commands</h3>
<p>We can create a new file with <code>open()</code>; we can add flags
to it such as: <code>O_CREAT</code>, <code>O_WRONLY</code> or
<code>O_TRUNC</code></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> O_CREAT<span class="op">|</span>O_WRONLY<span class="op">|</span>O_TRUNC<span class="op">,</span> S_IRUSR<span class="op">|</span>S_IWUSR<span class="op">);</span></span></code></pre></div>
<p>When we create a file with <code>open()</code> it returns a
[[file_descriptor]]. A file descriptor is an integer, private per
process, used in UNIX systems to access files. An opaque handle that
lets you do certain ops. A pointer to an object of type file.</p>
<p>Each process maintains an array of file descriptors. Each one refers
to an entry in the system-wide open file table.</p>
<p>When we call <code>write()</code> (update a file in persistent
storage) it acts as if it writes the updates right away but they
actually go into a buffer in memory then get written after a few
seconds.</p>
<p>To write to files right away, sometimes we use <code>fsync()</code>
this guarantees that the writes will be performed asap in critical
systems such as database mgmt systems.</p>
<p>When we call <code>mv foo bar</code> these are the system calls that
happen:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;foo.txt.tmp&quot;</span><span class="op">,</span> O_WRONLY<span class="op">|</span>O_CREAT<span class="op">|</span>O_TRUNC<span class="op">,</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>              S_IRUSR<span class="op">|</span>S_IWUSR<span class="op">);</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>write<span class="op">(</span>fd<span class="op">,</span> buffer<span class="op">,</span> size<span class="op">);</span> <span class="co">// write out new version of file</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>fsync<span class="op">(</span>fd<span class="op">);</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>close<span class="op">(</span>fd<span class="op">);</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>rename<span class="op">(</span><span class="st">&quot;foo.txt.tmp&quot;</span><span class="op">,</span> <span class="st">&quot;foo.txt&quot;</span><span class="op">);</span></span></code></pre></div>
<p>When we call <code>rm foo</code> it calls the following actions:</p>
<pre class="shell"><code>prompt&gt; strace rm foo
...
unlink(&quot;foo&quot;)                           = 0</code></pre>
<h3>Directories</h3>
<p>An empty directory contains <code>.</code> and <code>..</code></p>
<p>We can modify them with <code>mkdir</code>, and
<code>rmdir</code></p>
<p>A key part of directories is <code>link</code>. It basically creates
a new reference to the inode with your preferred file name.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> echo hello <span class="op">&gt;</span> file</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> cat file</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ex">hello</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> ln file file2</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> cat file2</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="ex">hello</span></span></code></pre></div>
<p>The file is not copied. You just now have two names.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> ls <span class="at">-i</span> file file2</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ex">67158084</span> file</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ex">67158084</span> file2</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span></span></code></pre></div>
<p>When we <code>unlink</code> we remove the references to that file.
Over time, the system will check the reference counts to that file and
if it reaches zero the system will free the inode and the related data
blocks.</p>
<p>We can also use symbolic links with:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> echo hello <span class="op">&gt;</span> file</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> ln <span class="at">-s</span> file file2</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ex">prompt</span><span class="op">&gt;</span> cat file2</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ex">hello</span></span></code></pre></div>
<p>The issue is that they might create a dangling reference if we remove
the file while keeping file2. They're its own type called:
<code>symbolic link</code></p>
<h3>Key terms</h3>
<ul>
<li>A <strong>file</strong> is an array of bytes which can be created,
read, written, and deleted. It has a low-level name (i.e., a number)
that refers to it uniquely. The low-level name is often called an
i-number.</li>
<li>A <strong>directory</strong> is a collection of tuples, each of
which contains a human-readable name and low-level name to which it
maps. Each entry refers either to another directory or to a file. Each
directory also has a low-level name (i-number) itself. A directory
always has two special entries: the . entry, which refers to itself, and
the .. entry, which refers to its parent.</li>
<li>A directory tree organizes all files into a large tree starting at
the <strong>root</strong></li>
<li>To access a file, a process must use a system call (usually, open())
to request permission from the operating system. If permission is
granted, the OS returns a <strong>file descriptor</strong>, which can
then be used for read or write access, as permissions and intent
allow.</li>
<li>Each file descriptor is a private, per-process entity, which refers
to an entry in the <strong>open file table</strong>. The entry therein
tracks which file this access refers to, the <strong>current
offset</strong> of the file (i.e., which part of the file the next read
or write will access), and other relevant information.</li>
<li>To force updates to persistent media, a process must use fsync() or
related calls. However, doing so correctly while maintaining high
performance is challenging [P+14], so think carefully when doing so</li>
<li>To have multiple human-readable names in the file system refer to
the same underlying file, use hard links or symbolic links. Each is
useful in different circumstances, so consider their strengths and
weaknesses before usage. And remember, deleting a file is just
performing that one last unlink() of it from the directory
hierarchy.</li>
</ul>
<h3>Implementing a File System</h3>
<p>Key questions:</p>
<ul>
<li>How do we implement a simple file system?</li>
<li>What are the data structure it needs</li>
<li>Even the simplest of operations like opening, reading, or writing a
file incurs a huge number of I/O operations, scattered over the disk.
What can a file system do to reduce the high costs of doing so many
I/Os?</li>
</ul>
<p><strong>i-Nodes</strong> Structure that holds metadata for a given
file (length, permissions, and location of its blocks) short for index
node. It is used to index into an array of on-disk inodes to find the
inode of that number. (can also be called dnode, fnodes, etc)</p>
<p>When engineers design file systems, they hold these high level
rules:</p>
<ul>
<li>Most files are small; 2K most common</li>
<li>Avg. file size is growing; 200K is avg</li>
<li>Most bytes are stored in large files; few big files occupy most of
the space</li>
<li>File systems contains lots of files; up to 100K on avg</li>
<li>Directories are typically small; most 20 or fewer</li>
</ul>
